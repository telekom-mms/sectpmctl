#! /bin/bash

# SECTPMCTL
# AUTHORS: Heike Pesch <heike.pesch@t-systems.com>
#          Richard Robert Reitz <richard-robert.reitz@t-systems.com>

PATH='/usr/sbin:/usr/bin:/sbin:/bin'

set -e

function rand8str()
{
  local n8="${1}"
  local kernel=""
  local openssl=""
  local tpm=""
  local xored=""

  for _ in $(seq 1 ${n8}); do
    kernel="$( xxd -l 8 -p /dev/random )"
    openssl="$( openssl rand -hex 8 )"
    tpm="$( tpm2_getrandom --hex 8 )"
    xored="${xored}$( printf '%016x\n' "$((0x${kernel} ^ 0x${openssl} ^ 0x${tpm}))" )"
  done
  
  echo "${xored}"
}


function rand8file()
{
  local n8="${1}"
  local file="${2}"

  local getrand=$(rand8str "${n8}")

  echo "${getrand}" | xxd -r -p - "${file}"
}

function rand8base64()
{
  local n8="${1}"
  local file="${2}"

  local getrand=$(rand8str "${n8}")

  echo "${getrand}" | base64 -w 0
}
_usage() {
  ME=$(basename "$0")
  #SCRIPTPATH="${FULLPATH%%/$ME}"
  cat <<__END
Usage: ${ME/-/ } COMMAND [OPTIONS]

COMMANDS
  check
  help
  install
    [--dont-extend] [--key <file>] [--password <tpm password>]
    [--preseed-pcr] [[--setrecoverykey][[--recoveryfile <file>]|[--recoveryscripthelper <file>]]]
    [--recoverygroups <num>] [--recoverygrouplength <num>  ]
  provisioning 
    [--lockoutAuth <password>]


OPTIONS
  install 
    --dont-extend
    --key <file>
    --preseed-pcr
    --recoveryfile <file>
    --recoveryscripthelper <file>
    --recoverygroups <num>
    --recoverygrouplength <num>  
    --setrecoverykey

  provisioning 
    --lockoutAuth <password> 

__END

}

_usage_long() {
  ME=$(basename "$0")
  #SCRIPTPATH="${FULLPATH%%/$ME}"
  cat <<__END
DESCRIPTION:
The Script will add TPM2-LUKS-KEY to an already existing LUKS Device.
Actually the Script is intended to be used with ONE LUKS Device only.
Secure Boot needs to be enabled.

The TPM2 Key will be an autogenerated Key.

USAGE:  
${ME/-/ } COMMAND [OPTIONS]

COMMANDS
  check
  help
  install
    [--dont-extend] [--key <file>] [--password <TPM password>]
    [--preseed-pcr] [[--setrecoverykey][[--recoveryfile <file>]|[--recoveryscripthelper <file>]]]
    [--recoverygroups <num>] [--recoverygrouplength <num>  ] [--setrecoverykey]
  provisioning 
    [--lockout-auth <password>]

OPTIONS

  install

    Installs sectpmctl TPM2-LUKS-Encryption for Ubuntu.

    Check TPM2 and SecureBoot state. Add initial TPM2 LUKSKEY, generate unseal script, 
    generate TPM2 Policy, edit cryttab, set umask for initramfs, add hooks and
    updates intramfs.

    For more information on how to depoly read:
    https://github.com/T-Systems-MMS/sectpmctl/blob/main/README.md


    --dont-extend

      Dont extend PCR set in initrd for later use


    --key <file>

      LUKS Keyfile which can be used to add Key.
      Must be an absolute path. 
      Reads from stdin if this option is not given.


    --password <TPM password>

      Seal the LUKS key to PCR values and a password. Internally this
      option is not combined with the --noda option to enable DA
      protection. When unsealing while booting, the same TPM password
      has to be provided. The password can be changed at runtime with:
      sectpmctl key changepassword --handle 0x81000102 \
          --oldpassword "myoldpwd" --password "mynewpwd"
      If the current password is lost, a new password can be set with
      the recovery key by installing again:
      sectpmctl tpm install --password "mynewpwd" ...


    --setrecoverykey

      Creates and set a recovery key and prints it on STDOUT.

      CAUTION:
      Default: Don't set a recover key

      It is highly recommended to --setrecoverykey on installtion. 
      Store this key in a safe location. Without this key you 
      can loose all your data when the TPM breaks or when accessing 
      your hard disk in another machine. You have been warned!
      
      It can be written to a file (--recoveryfile)
      or uploaded to a server (--recoveryscripthelper)


    --recoveryfile <absolute filename>

      Writes the recovery key if enabled to a file.
      Must be an absolute path.
      
      Requires --setrecoverykey to be set.


    --recoveryscripthelper <file>

      Requires a Script as argument.

      Uploads the recovery key if enabled to a server
      by using a helper script. Has to be an absolute path.

      Recovery Helper Scripts must be provided by you, we
      won't maintain this.

      Requires --setrecoverykey to be set.
      

    --recoverygroups <num>
        
      Specifies the number of character groups used for the generated recovery key.
      Default: 8


    --recoverygrouplength <num>  
        
      Specifies the amount of characters used in each group for the
      generated recovery key. Default: 8


    --preseed-pcr

      This option is used for automated Ubuntu installation


  check

    Currently it checks if TPM2 is found, performs TPM2 selftest
    and check if SecureBoot is enabled.


  provisioning [--lockout-auth <password>]

    Perform the TPM provioning process. The TPM will be
    _cleared_ with this command and a new lockoutAuth is set.

    During TPM2 provisioning a random lockout auth password is generated
    and stored in _${SECTPMCTL_KEYS}/lockout.pwd_

    Sane dictionary attack lockout time penalty is set and 
    two TPM primary keys are created. 
    One with dictionary attack lockout flag (DA) and 
    one without (NODA).

    If the TPM2 has been already provisioned, the current
    lockoutAuth is required. Otherwise it has to be cleared
    in the BIOS.

  --lockout-auth <password>

      A valid lockout auth password is needed if set in TPM. 

      If the password is lost, clear the TPM in the BIOS or try:
      $ echo 5 | sudo tee /sys/class/tpm/tpm0/ppi/request
      $ reboot


  help

     Open this help message.

EXAMPLES

  Check TPM2 and SecureBoot State

    $ sudo ${ME/-/ } check

  Provision TPM2

    $ sudo ${ME/-/ } provisioning


  Initial Installtion TPM2-LUKS 
    # Requries the sectpmctl bootloader to be installed!
    # $ sudo sectpmctl boot install
    # $ sudo reboot
    $ sudo ${ME/-/ } install --setrecoverykey

    $ sudo ${ME/-/ } install --setrecoverykey --recoveryfile /path/to/my/secret.key

    $ sudo ${ME/-/ } install --password "0q4c3kc8" --setrecoverykey

    CAUTION:
    The Example command will print out the recovery key.
    It is highly recommended to store this key in a safe location. Without 
    this key you can loose all your data when the TPM breaks or when accessing 
    your hard disk in another machine. You have been warned!


__END
exit 0
}


_check_input() {
  test $# -eq 0 && _usage && exit 0
  [[ ! -f /etc/crypttab ]] && (echo 'System is not encrypted. Abort.'; exit 1; )
  # @TODO remove export this might later not be necessary
  export SECTPMCTL_KEYS="/var/lib/sectpmctl/keys"
  export INITIAL="false"
  export SEAL="false"
  export CHANGEPIN="false"
  export CHECK="false"
  export EXTEND="true"
  export PCR_BANK="sha256"
  # PCR 8,9,11 and 14 are always added
  export PCR_VALUES_TO_USE="7"
  export PERSISTANT_OWNER_SRK="0x81000100"
  export PERSISTANT_OWNER_SRK_NODA="0x81000101"
  export PERSISTANT_HANDLE_TO_USE="0x81000102"
  export KEY_SCRIPT="/var/lib/sectpmctl/scripts/unsealtpmluks.sh"
  export CRYPTROOT_LABEL=""
  export KEY_FILE=""
  export TPM_KEYSLOT="5"
  export SET_RECOVERY_KEY=""
  export RECOVERY_FILE=""
  export RECOVERY_SCRIPT_HELPER=""
  export RECOVERY_GROUPS="8"
  export RECOVERY_GROUP_LENGTH="8"
  export RECOVERY_KEYSLOT="0"
  export DO_PROVISIONING=""
  export PROVISIONING_LOCKOUT_AUTH=""
  export KNOWN_UNKNOWN=""
  export TPM_PASSWORD=""

  ME=$(basename "$0")
  while [ $# != 0 ]; do
    case "$1" in
      --key)
        if (( $# >= 2 )) && [[ ! "$2" =~ ^- ]]; then
          export KEY_FILE="${2}"
          shift
        else
          echo "--key requires an argument"
          exit 1
        fi
        ;;
      --setrecoverykey)
        export SET_RECOVERY_KEY="true"
        ;;
      --recoveryfile)
        if (( $# >= 2 )) && [[ ! "$2" =~ ^- ]]; then
          export RECOVERY_FILE="${2}"
          shift
        else
          echo "--recoveryfile requires an argument"
          exit 1
        fi
        ;;
      --recoveryscripthelper)
        if (( $# >= 2 )) && [[ ! "$2" =~ ^- ]]; then
          export RECOVERY_SCRIPT_HELPER="${2}"
          shift
        else
          echo "--recoveryscripthelper requires an argument"
          exit 1
        fi
        ;;
      --recoverygroups)
        if (( $# >= 2 )) && [[ ! "$2" =~ ^- ]]; then
          export RECOVERY_GROUPS="${2}"
          shift
        else
          echo "--recoverygroups requires an argument"
          exit 1
        fi
        ;;
      --recoverygrouplength)
        if (( $# >= 2 )) && [[ ! "$2" =~ ^- ]]; then
          export RECOVERY_GROUP_LENGTH="${2}"
          shift
        else
          echo "--recoverygrouplength requires an argument"
          exit 1
        fi
        ;;
      --dont-extend)
        export EXTEND="false"
        ;;
      install)
        export INITIAL="true"
        ;;
      --password)
        if (( $# >= 2 )) && [[ ! "$2" =~ ^- ]]; then
          export TPM_PASSWORD="${2}"
          shift
        else
          echo "--password requires an argument"
          exit 1
        fi
        ;;
      --preseed-pcr)
        export PCR_VALUES_TO_USE="0"
        ;;
      check)
        export CHECK="true"
        ;;
      provisioning)
        export DO_PROVISIONING="true"
        ;;
      --lockout-auth)
        if (( $# >= 2 )) && [[ ! "$2" =~ ^- ]]; then
          export PROVISIONING_LOCKOUT_AUTH="${2}"
          shift
        else
          echo "${2} is not a valid lockout auth. See example seciton"
          exit 1
        fi
        ;;
      --help|help|-h)
        _usage_long "${VERSION}"
        ;;
      *)
          echo "'${1}' is not a valid option. See '${ME/-/ } help'"
          exit 1
        ;;
    esac
    shift
  done

  # read key if not given
  if [[ "x$KEY_FILE" == "x" ]] && [[ "x$INITIAL" == "xtrue" || "x$SEAL" == "xtrue" ]]; then
    if [[ -t 0 ]]; then
      # stdin is coming from the terminal
      echo -n "Enter LUKS Password: "
      read -sr line || true
      export KNOWN_UNKNOWN="$line"
      echo
    else
      # from pipe or redirection
      export KNOWN_UNKNOWN="$(</dev/stdin)"
    fi
    if [[ "x$KNOWN_UNKNOWN" == "x" ]]; then
      echo "${ME/-/ } requires a password, exit"
      exit 1
    fi
  fi

  # @TODO THIS COULD CAUSE TROUBLE IF MORE THAN ONE LUKS DEVICE!
  CRYPTROOT_LABEL=$(cat < /etc/crypttab | awk '{print $1}')
  CRYPT_PARTITION=$(blkid -o device --match-token 'TYPE="crypto_LUKS"')
  ROOTCRYPTPARTUUID=$(blkid -s UUID -o value "${CRYPT_PARTITION}")

  [[ "${INITIAL}" == "true" ]] \
    && initial_tpm2_setup \
      "${PCR_BANK}" \
      "${PCR_VALUES_TO_USE}" \
      "${PERSISTANT_HANDLE_TO_USE}" \
      "${KEY_FILE}" \
      "${KEY_SCRIPT}" \
      "${TPM_KEYSLOT}"  \
      "${CRYPTROOT_LABEL}" \
      "${ROOTCRYPTPARTUUID}" \
      "${CRYPT_PARTITION}" \
      "${EXTEND}" \
      "${SET_RECOVERY_KEY}" \
      "${RECOVERY_FILE}" \
      "${RECOVERY_SCRIPT_HELPER}" \
      "${RECOVERY_GROUPS}" \
      "${RECOVERY_GROUP_LENGTH}" \
      "${RECOVERY_KEYSLOT}" \
      "${KNOWN_UNKNOWN}" \
      "${PERSISTANT_OWNER_SRK_NODA}" \
      "${SECTPMCTL_KEYS}" \
      "${TPM_PASSWORD}"

  [[ "${CHECK}" == "true" ]] \
    && check_tpm2_secureboot

  [[ "${DO_PROVISIONING}" == "true" ]] \
    && do_provisioning \
      "${SECTPMCTL_KEYS}" \
      "${PROVISIONING_LOCKOUT_AUTH}" \
      "${PERSISTANT_OWNER_SRK}" \
      "${PERSISTANT_OWNER_SRK_NODA}"

  exit 0
}

do_provisioning() {
  SECTPMCTL_KEYS="${1}"
  PROVISIONING_LOCKOUT_AUTH="${2}"
  PERSISTANT_OWNER_SRK="${3}"
  PERSISTANT_OWNER_SRK_NODA="${4}"
  
  if [[ "x${PROVISIONING_LOCKOUT_AUTH}" == "x" ]] && [[ $(tpm2_getcap properties-variable | grep -c "lockoutAuthSet:.*1") == 1 ]]; then
    echo "lockoutAuth set in TPM. use --lockout-auth <password> to set it."
    echo "if the password is lost, clear the TPM in the BIOS or try:"
    echo "$ echo 5 | sudo tee /sys/class/tpm/tpm0/ppi/request"
    echo "$ reboot"
    echo
    echo "warning: this command will clear all keys!"
    exit 1
  fi

  LOCKOUT_FILE="${SECTPMCTL_KEYS}/lockout.pwd"
  
  echo "START PROVISIONING"

  echo "## TPM CLEAR"
  
  if [[ "x${PROVISIONING_LOCKOUT_AUTH}" != "x" ]]; then
    tpm2_clear -Q "${PROVISIONING_LOCKOUT_AUTH}"
  else
    tpm2_clear -Q
  fi
  
  echo "## SET DICTIONARY LOCKOUT SETTINGS"
  
  tpm2_dictionarylockout -Q --max-tries=32 --recovery-time=600 --lockout-recovery-time=1800 --setup-parameters
  
  echo "## CREATE AND SET THE LOCKOUTAUTH VALUE"
  
  # create lockout password required for provisioning
  shred -f -z -u "${LOCKOUT_FILE}" 2> /dev/null > /dev/null || true
  getrand=$(rand8base64 2)
  echo "${getrand}" | head -c 32 > "${LOCKOUT_FILE}"
  chown root:root "${LOCKOUT_FILE}"
  chmod 0600 "${LOCKOUT_FILE}"
  
  # set lockout password
  tpm2_changeauth -Q --object-context=lockout "$(cat "${LOCKOUT_FILE}")"

  tempdir=$(mktemp -d -p /dev/shm)
  chmod 700 "${tempdir}"
  cd "${tempdir}" || exit

  echo "## CREATE PERSISTENT PRIMARY OWNER SRK AT ${PERSISTANT_OWNER_SRK}"

  if [[ -f "${SECTPMCTL_KEYS}/tpm_owner.pub" ]]; then
    shred -f -z -u "${SECTPMCTL_KEYS}/tpm_owner.pub"
  fi
  tpm2_evictcontrol -Q --hierarchy=o --object-context="${PERSISTANT_OWNER_SRK}" 2> /dev/null || true
  shred -f -z -u "${SECTPMCTL_KEYS}/tpm_owner.pub" 2> /dev/null > /dev/null || true
  tpm2_createprimary -Q --hierarchy=o --key-algorithm=rsa --key-context=prim.ctx
  tpm2_evictcontrol -Q --hierarchy=o --object-context=prim.ctx "${PERSISTANT_OWNER_SRK}"
  tpm2_readpublic -Q --object-context="${PERSISTANT_OWNER_SRK}" --serialized-handle="${SECTPMCTL_KEYS}/tpm_owner.pub"
  chmod 600 "${SECTPMCTL_KEYS}/tpm_owner.pub"
  shred -f -z -u prim.ctx

  echo "## CREATE PERSISTENT PRIMARY OWNER NODA SRK AT ${PERSISTANT_OWNER_SRK_NODA}"

  if [[ -f "${SECTPMCTL_KEYS}/tpm_owner_noda.pub" ]]; then
    shred -f -z -u "${SECTPMCTL_KEYS}/tpm_owner_noda.pub"
  fi
  tpm2_evictcontrol -Q --hierarchy=o --object-context="${PERSISTANT_OWNER_SRK_NODA}" 2> /dev/null || true
  shred -f -z -u "${SECTPMCTL_KEYS}/tpm_owner_noda.pub" 2> /dev/null > /dev/null || true
  tpm2_createprimary -Q --hierarchy=o --key-algorithm=rsa --key-context=prim_noda.ctx --attributes="fixedtpm|fixedparent|sensitivedataorigin|userwithauth|restricted|decrypt|noda"
  tpm2_evictcontrol -Q --hierarchy=o --object-context=prim_noda.ctx "${PERSISTANT_OWNER_SRK_NODA}"
  tpm2_readpublic -Q --object-context="${PERSISTANT_OWNER_SRK_NODA}" --serialized-handle="${SECTPMCTL_KEYS}/tpm_owner_noda.pub"
  chmod 600 "${SECTPMCTL_KEYS}/tpm_owner_noda.pub"
  shred -f -z -u prim_noda.ctx

  cd - > /dev/null || exit
  rmdir "${tempdir}"
}

generate_unseal_script() {
  PCR_BANK="${1}"
  PERSISTANT_HANDLE_TO_USE="${2}"
  KEY_SCRIPT="${3}"
  CRYPT_PARTITION="${4}"
  EXTEND="${5}"
  SECTPMCTL_KEYS="${6}"
  TPM_PASSWORD="${7}"
  
  # settings for retries in passwordless unsealing
  UNSEAL_RETRY_COUNT="5"
  UNSEAL_RETRY_SLEEP="2"

  CREATE_PRIMARY_HASH="sha256"
  if [[ $(tpm2_getcap algorithms | grep -c 'sha384:') == 1 ]]; then
    CREATE_PRIMARY_HASH="sha384"
  fi

  # calculate length of hash in bytes
  if [[ -f /tmp/hashlength ]]; then
    rm /tmp/hashlength
  fi
  echo test | openssl dgst -${PCR_BANK} -binary -out /tmp/hashlength
  HASH_LENGTH=$(stat --printf="%s" /tmp/hashlength)
  rm /tmp/hashlength

  echo "CREATE AND ADD TPM UNSEAL SCRIPT"
  # KEYSCRIPT FOR TRANSPARENT ENCRYPTION ON BOOT
  if [[ "${EXTEND}" == "true" ]]; then
    if [[ -n ${TPM_PASSWORD} ]]; then
      cat > "${KEY_SCRIPT}" <<__EOT
#! /bin/bash -

exec 3>&1 1>&2

echo
echo sectpmctl
echo

mkdir /dev/shm > /dev/null 2> /dev/null
mount -t tmpfs tmpfs /dev/shm

tpm2_flushcontext -t
tpm2_flushcontext -l
tpm2_flushcontext -s

tpm2_pcrread sha256:11 | grep -q "^[[:space:]]\+11:[[:space:]]\+0x[0]\+$"
if [ \$? -eq 0 ]; then
        cryptsetup luksDump "${CRYPT_PARTITION}" > luks.dat
        sectpmctl key extend --file luks.dat
        shred -f -z -u luks.dat
fi

echo -n "Enter TPM Password: "
read -sr password || true
echo

sectpmctl key unseal --handle "${PERSISTANT_HANDLE_TO_USE}" --password "\${password}" --pcr-extend 1>&3 3>&-
retValUnseal=\$?

if [ \$retValUnseal -ne 0 ]; then
        umount /dev/shm
        echo UNSEAL FAILED, CHECKING RECOVERY KEY
        echo -n "\${password}" 1>&3 3>&-
        exit 1
fi

sectpmctl key extend --random
retValExtend=\$?

umount /dev/shm

if [ \$retValExtend -ne 0 ]; then
        echo KEY COULD NOT BE SECURED. PLEASE REBOOT.
        echo
        while true; do
                sleep 9999
        done
fi

echo UNSEALED, EXTENDED
echo
__EOT
    else
      cat > "${KEY_SCRIPT}" <<__EOT
#! /bin/bash -

exec 3>&1 1>&2

if [ "\$CRYPTTAB_TRIED" = 0 ]; then
        echo
        echo sectpmctl
        echo
        
        mkdir /dev/shm > /dev/null 2> /dev/null
        mount -t tmpfs tmpfs /dev/shm

        tpm2_flushcontext -t
        tpm2_flushcontext -l
        tpm2_flushcontext -s

        cryptsetup luksDump "${CRYPT_PARTITION}" > luks.dat
        sectpmctl key extend --file luks.dat
        shred -f -z -u luks.dat

        retValUnseal=1
        for _ in {1..${UNSEAL_RETRY_COUNT}}; do
                sectpmctl key unseal --handle "${PERSISTANT_HANDLE_TO_USE}" --noda --pcr-extend 1>&3 3>&-
                retValUnseal=\$?

                if [ \$retValUnseal -eq 0 ]; then
                        break
                else
                        echo Kernel maybe busy, please wait
                        sleep ${UNSEAL_RETRY_SLEEP}
                fi
        done

        sectpmctl key extend --random
        retValExtend=\$?

        umount /dev/shm
        
        if [ \$retValUnseal -ne 0 ]; then
                echo UNSEAL FAILED
                echo
                exit 1
        fi
        
        if [ \$retValExtend -ne 0 ]; then
                echo KEY COULD NOT BE SECURED. PLEASE REBOOT.
                echo
                while true; do
                        sleep 9999
                done
        fi

        echo UNSEALED, EXTENDED
        echo
else
        keyscript="/lib/cryptsetup/askpass"
        keyscriptarg="Enter Recovery Key: "
        exec "\$keyscript" "\$keyscriptarg" 1>&3 3>&-
fi
__EOT
    fi
  else
    cat > "${KEY_SCRIPT}" <<__EOT
#! /bin/sh -

exec 3>&1 1>&2

if [ "\$CRYPTTAB_TRIED" = 0 ]; then
        echo
        echo sectpmctl, only for preseed usage!
        echo

        mkdir /dev/shm > /dev/null 2> /dev/null
        mount -t tmpfs tmpfs /dev/shm

        tpm2_flushcontext -t
        tpm2_flushcontext -l
        tpm2_flushcontext -s

        cryptsetup luksDump "${CRYPT_PARTITION}" > luks.dat
        sectpmctl key extend --file luks.dat
        shred -f -z -u luks.dat

        retValUnseal=1
        for _ in {1..${UNSEAL_RETRY_COUNT}}; do
                sectpmctl key unseal --handle "${PERSISTANT_HANDLE_TO_USE}" --noda --pcr-extend --pcr-preseed 1>&3 3>&-
                retValUnseal=\$?

                if [ \$retValUnseal -eq 0 ]; then
                        break
                else
                        echo Kernel maybe busy, please wait
                        sleep ${UNSEAL_RETRY_SLEEP}
                fi
        done

        umount /dev/shm
        
        if [ \$retValUnseal -ne 0 ]; then
                echo UNSEAL FAILED
                echo
                exit 1
        fi

        echo PRESEED UNSEALED, UNEXTENDED
        echo
else
        keyscript="/lib/cryptsetup/askpass"
        keyscriptarg="Enter Recovery Key: "
        exec "\$keyscript" "\$keyscriptarg" 1>&3 3>&-
fi
__EOT
  fi

  chmod +x "${KEY_SCRIPT}"
}

function create_recovery_key()
{
  local RECOVERY_GROUPS="${1}"
  local RECOVERY_GROUP_LENGTH="${2}"

  # check input parameters
  if ((RECOVERY_GROUP_LENGTH < 1)); then
    echo "Error, invalid recovery group length, has to be greater then 0" > /dev/stderr
    exit 1
  fi
  if ((RECOVERY_GROUP_LENGTH%2 == 1)); then
    echo "Error, invalid recovery group length, hast to be a multiple of 2" > /dev/stderr
    exit 1
  fi
  if ((RECOVERY_GROUPS < 1)); then
    echo "Error, invalid recovery groups, has to be greater then 0" > /dev/stderr
    exit 1
  fi

  local RECOVERY_KEY=""
  local RANDOM_GROUP=""

  for ((i = RECOVERY_GROUPS-1; i >= 0; i--)); do
    getrand=$(rand8str 1)
    RANDOM_GROUP="$(echo "${getrand}" | head -c "${RECOVERY_GROUP_LENGTH}")"

    # check if openssl output contains non hex characters
    echo "${RANDOM_GROUP}" | grep -Eq '^[0-9a-f]+$' || { echo "Error, created recovery key has wrong characters" > /dev/stderr; exit 1;}

    RECOVERY_KEY="${RECOVERY_KEY}${RANDOM_GROUP}"
    if ((i != 0)); then
      RECOVERY_KEY="${RECOVERY_KEY}-"
    fi
  done

  # check for correct length of recovery key
  if ((${#RECOVERY_KEY} != RECOVERY_GROUPS*$((RECOVERY_GROUP_LENGTH+1))-1)); then
    echo "Error, created recovery key has wrong length" > /dev/stderr
    exit 1
  fi
  # check if recovery key is too simple like 0000-0000-0000-...
  if (($(echo -n "${RECOVERY_KEY}" | sed 's/-//g' | sed 's/\(.\)/\1\n/g' | sort -u | wc -l) < 2)); then
    echo "Error, created recovery key is too simple" > /dev/stderr
    exit 1
  fi

  echo "${RECOVERY_KEY}"
}

generate_tpm2_policy() {
  PCR_BANK="${1}"
  PCR_VALUES_TO_USE="${2}"
  TPM2_PERSISTANT_HANDLE_TO_USE="${3}"
  KEY_FILE="${4}"
  TPM_KEYSLOT="${5}"
  CRYPT_PARTITION="${6}"
  SET_RECOVERY_KEY="${7}"
  RECOVERY_FILE="${8}"
  RECOVERY_SCRIPT_HELPER="${9}"
  RECOVERY_GROUPS="${10}"
  RECOVERY_GROUP_LENGTH="${11}"
  RECOVERY_KEYSLOT="${12}"
  KNOWN_UNKNOWN="${13}"
  PERSISTANT_OWNER_SRK_NODA="${14}"
  SECTPMCTL_KEYS="${15}"
  TPM_PASSWORD="${16}"

  # calculate length of hash in bytes
  if [[ -f /tmp/hashlength ]]; then
    rm /tmp/hashlength
  fi
  echo test | openssl dgst -${PCR_BANK} -binary -out /tmp/hashlength
  HASH_LENGTH=$(stat --printf="%s" /tmp/hashlength)
  rm /tmp/hashlength
  
  echo "USING ${PCR_BANK} HASH WITH SIZE ${HASH_LENGTH}"

  echo "## CRYPT PARTITION: ${CRYPT_PARTITION}"

  TEMPDIR=""
  TEMPDIR="$(mktemp -d -p /tmp)"
  chmod 700 "${TEMPDIR}"
  TPM_SECRET_LUKS_KEY="tpmkey"

  mount -t tmpfs "${TEMPDIR##*/}" "${TEMPDIR}"

  echo "CREATE AND ADD TPM POLICY IN TMPFS DIRECTORY ${TEMPDIR}"
  cd "${TEMPDIR}" || exit 1

  echo "CREATE SECRET TPM LUKS KEY"
  rand8file 16 "${TPM_SECRET_LUKS_KEY}"

  if [[ $( cryptsetup luksDump "${CRYPT_PARTITION}" | grep -c "${TPM_KEYSLOT}: luks2") != 0 ]]; then
    echo "KILL EXISTING TPM LUKS KEY FROM KEYSLOT"
    if [[ "x${KEY_FILE}" == "x" ]]; then
      echo -n "${KNOWN_UNKNOWN}" | cryptsetup \
        luksKillSlot \
        "${CRYPT_PARTITION}" \
        "${TPM_KEYSLOT}" || ( echo "COULD NOT KILL KEYSLOT" && exit 2 )
    else
      cryptsetup \
        --key-file="${KEY_FILE}" \
        luksKillSlot \
        "${CRYPT_PARTITION}" \
        "${TPM_KEYSLOT}" || ( echo "COULD NOT KILL KEYSLOT" && exit 2 )
    fi
  fi

  echo "ADD NEW GENERATED SECRET TPM LUKS KEY"
  if [[ "x${KEY_FILE}" == "x" ]]; then
    echo -n "${KNOWN_UNKNOWN}" | cryptsetup \
      --key-slot="${TPM_KEYSLOT}" \
      luksAddKey \
      "${CRYPT_PARTITION}" \
      "${TPM_SECRET_LUKS_KEY}" || ( echo "COULD NOT ADD KEY" && exit 2 )
  else
    cryptsetup \
      --key-slot="${TPM_KEYSLOT}" \
      --key-file="${KEY_FILE}" \
      luksAddKey \
      "${CRYPT_PARTITION}" \
      "${TPM_SECRET_LUKS_KEY}" || ( echo "COULD NOT ADD KEY" && exit 2 )
  fi
  
  echo "EXTEND PCR 11"
  sectpmctl key extend --random

  # Create empty dat for PCR 8, 9 and 14
  if [[ -f "${SECTPMCTL_KEYS}/pcrNull.dat" ]]; then
    rm -f "${SECTPMCTL_KEYS}/pcrNull.dat"
  fi
  dd if=/dev/zero of="${SECTPMCTL_KEYS}/pcrNull.dat" bs=1 count="${HASH_LENGTH}" conv=excl,fsync
  chmod 600 "${SECTPMCTL_KEYS}/pcrNull.dat"

  # optional key creation and escrow
  if [[ "x${SET_RECOVERY_KEY}" == "xtrue" ]]; then
    echo "SET RECOVERY KEY"
    RECOVERY_KEY="$(create_recovery_key ${RECOVERY_GROUPS} ${RECOVERY_GROUP_LENGTH})" || exit 1

    echo -n "$RECOVERY_KEY" > "./keyfile"

    if [[ ! "x${RECOVERY_FILE}" == "x" ]]; then
      echo "${RECOVERY_KEY}" > "${RECOVERY_FILE}"
    elif [[ ! "x${RECOVERY_SCRIPT_HELPER}" == "x" ]]; then
      "${RECOVERY_SCRIPT_HELPER}" "${RECOVERY_KEY}"
    else
      echo
      echo "########################################"
      echo "########################################"
      echo
      echo "WARNING!"
      echo "Please save this recovery in a safe place."
      echo "When lost you will have difficulties to recover."
      echo "If the TPM is deleted or secureboot changed, you"
      echo "will not be able to recover in case of a lost"
      echo "recovery key!"
      echo
      echo "RECOVERY KEY: ${RECOVERY_KEY}"
      echo
      echo "########################################"
      echo "########################################"
      echo
    fi

    if [[ "x${KEY_FILE}" == "x" ]]; then
      echo -n "${KNOWN_UNKNOWN}" | cryptsetup \
        --key-slot="${RECOVERY_KEYSLOT}" \
        luksChangeKey \
        "${CRYPT_PARTITION}" \
        "./keyfile" || ( echo "COULD NOT SET RECOVERY KEY" && exit 2 )
    else
      cryptsetup \
        --key-slot="${RECOVERY_KEYSLOT}" \
        --key-file="${KEY_FILE}" \
        luksChangeKey \
        "${CRYPT_PARTITION}" \
        "./keyfile" || ( echo "COULD NOT SET RECOVERY KEY" && exit 2 )
    fi
    shred -f -z -u "./keyfile"
  fi

  echo "CREATING PCR VALUES"
  if (( PCR_VALUES_TO_USE == 7 )); then
    if [[ -f "${SECTPMCTL_KEYS}/pcr7.dat" ]]; then
      rm -f "${SECTPMCTL_KEYS}/pcr7.dat"
    fi
    tpm2_pcrread -Q \
      --output="${SECTPMCTL_KEYS}/pcr7.dat" \
      ${PCR_BANK}:${PCR_VALUES_TO_USE}
    chmod 600 "${SECTPMCTL_KEYS}/pcr7.dat"
  fi

  if [[ -f "${SECTPMCTL_KEYS}/pcr11.dat" ]]; then
    rm -f "${SECTPMCTL_KEYS}/pcr11.dat"
  fi
  # Calculate expected value for PCR 11
  cryptsetup luksDump "${CRYPT_PARTITION}" | openssl dgst -${PCR_BANK} -binary -out pcr11luks.dat -
  cat "${SECTPMCTL_KEYS}/pcrNull.dat" pcr11luks.dat > pcr11combined.dat
  openssl dgst -${PCR_BANK} -binary -out "${SECTPMCTL_KEYS}/pcr11.dat" pcr11combined.dat
  chmod 600 "${SECTPMCTL_KEYS}/pcr11.dat"
  shred -f -z -u pcr11luks.dat pcr11combined.dat

  echo "SEAL LUKS KEY to TPM"
  USE_PRESEED_PCR=""
  if (( PCR_VALUES_TO_USE == 0 )); then
    USE_PRESEED_PCR="--pcr-preseed"
  fi
  if [[ -n ${TPM_PASSWORD} ]]; then
    sectpmctl key seal --handle "${PERSISTANT_HANDLE_TO_USE}" --key-file "${TPM_SECRET_LUKS_KEY}" --password "${TPM_PASSWORD}" --pcr-extend ${USE_PRESEED_PCR}
  else
    sectpmctl key seal --handle "${PERSISTANT_HANDLE_TO_USE}" --key-file "${TPM_SECRET_LUKS_KEY}" --noda --pcr-extend ${USE_PRESEED_PCR}
  fi

  shred -f -z -u "${TPM_SECRET_LUKS_KEY}"
  
  cd - > /dev/null
  umount "${TEMPDIR}"
  rmdir "${TEMPDIR}"
  
  echo "DONE"
}

edit_crypttab() {
  CRYPT_LABEL="${1}"
  KEY_SCRIPT="${2}"
  UUID="${3}"
  echo "## EDIT CRYPTTAB"
  # <target name>	<source device>		<key file>	<options>
  LINE_IN_FILE="${CRYPT_LABEL} UUID=${UUID} none luks,keyscript=${KEY_SCRIPT}"
  cp -a /etc/crypttab "/etc/ctypttab-$(date +%F)"
  if [[ $(grep -c "${UUID}" /etc/crypttab) == 0 ]]; then
    echo "${LINE_IN_FILE}" >> /etc/crypttab
  else
    CR_LINENR=$(grep -n "${UUID}" /etc/crypttab)
    LINENR="${CR_LINENR%%:*}"
    sed -i "${LINENR} {/^.*$/d}" /etc/crypttab
    echo "${LINE_IN_FILE}" >> /etc/crypttab
  fi
}

edit_initramfs_conf() {
  echo "## SET UMASK IN /etc/initramfs-tools/initramfs.conf"
  CONFIG_FILE="/etc/initramfs-tools/initramfs.conf"
  cp -a "${CONFIG_FILE}" "${CONFIG_FILE}-$(date +%F)"
  if [[ $(grep -c "UMASK" "${CONFIG_FILE}") != 0 ]]; then
    sed -i '/^[#\s]*\(UMASK=\)[0-9]\+/d' "${CONFIG_FILE}"
  fi
  echo "UMASK=0077" >> "${CONFIG_FILE}"
}

# @TODO Check if we need to put all the bins
# to initramfs - shaXsum should not be need
add_tpm2_hook() {
  PCR_BANK="${1}"
  SECTPMCTL_KEYS="${2}"
  # TPM2 HOOK FOR INITRAMFS
  HOOKFILE="/etc/initramfs-tools/hooks/tpm2.sh"
  echo "CREATE AND ADD TPM INITRAMFS HOOK"
cat > "${HOOKFILE}" <<__EOT
#! /bin/sh
PREREQ=""
prereqs()
{
  echo "\$PREREQ"
}

case \$1 in
  prereqs)
    prereqs
    exit 0
    ;;
esac

. /usr/share/initramfs-tools/hook-functions

copy_exec /bin/bash /bin

copy_exec ${SECTPMCTL_KEYS}/tpm_owner.pub ${SECTPMCTL_KEYS}/tpm_owner.pub
copy_exec ${SECTPMCTL_KEYS}/tpm_owner_noda.pub ${SECTPMCTL_KEYS}/tpm_owner_noda.pub

copy_exec /usr/bin/awk /usr/bin
copy_exec /usr/bin/basename /usr/bin
copy_exec /usr/bin/cat /usr/bin
copy_exec /usr/bin/grep /usr/bin
copy_exec /usr/bin/install /usr/bin
copy_exec /usr/bin/mktemp /usr/bin
copy_exec /usr/bin/od /usr/bin
copy_exec /usr/bin/realpath /usr/bin
copy_exec /usr/bin/rmdir /usr/bin
copy_exec /usr/bin/sha256sum /usr/bin
copy_exec /usr/bin/sha384sum /usr/bin
copy_exec /usr/bin/sha512sum /usr/bin
copy_exec /usr/bin/shred /usr/bin
copy_exec /usr/bin/timeout /usr/bin
copy_exec /usr/bin/tpm2_flushcontext /usr/bin
copy_exec /usr/bin/tpm2_getcap /usr/bin
copy_exec /usr/bin/tpm2_getrandom /usr/bin
copy_exec /usr/bin/tpm2_load /usr/bin
copy_exec /usr/bin/tpm2_pcrextend /usr/bin
copy_exec /usr/bin/tpm2_pcrread /usr/bin
copy_exec /usr/bin/tpm2_policyauthvalue /usr/bin
copy_exec /usr/bin/tpm2_policypcr /usr/bin
copy_exec /usr/bin/tpm2_sessionconfig /usr/bin
copy_exec /usr/bin/tpm2_startauthsession /usr/bin
copy_exec /usr/bin/tpm2_unseal /usr/bin
copy_exec /usr/bin/tr /usr/bin
copy_exec /usr/bin/wc /usr/bin

copy_exec /usr/sbin/sectpmctl /usr/sbin

copy_exec /usr/lib/sectpmctl/scripts/sectpmctl-key /usr/lib/sectpmctl/scripts/sectpmctl-key
copy_exec /usr/lib/x86_64-linux-gnu/libtss2-tcti-device.so.0 /usr/lib/x86_64-linux-gnu

force_load tpm_tis
force_load tpm_crb
__EOT
  chmod +x "${HOOKFILE}"
}

update_initramfs() {
  # UPDATE INITRAMFS WHICH ALSO UPDATES THE BOOTLOADER
  echo "UPDATE INITRAMFS"
  update-initramfs -u -k all
}

check_tpm2_secureboot () {
  echo 'Check if TPM was found during boot'
  dmesg | grep -i 'TPM' || (echo 'TPM NOT FOUND' ; exit 3)

  echo 'TPM2 Selftest'
  tpm2_selftest || (echo 'TPM Selftest Failed' ; exit 3)
}

check_initial_luks_passphrase() {
  KNOWN_UNKNOWN="${1}"
  CRYPT_PARTITION="${2}"
  CRYPTROOT_LABEL="${3:=testfoo}"

  echo 'Check if proper LUKS Key is given for initial setup'
  echo -n "${KNOWN_UNKNOWN}" \
    | cryptsetup open --test-passphrase "${CRYPT_PARTITION}" "${CRYPTROOT_LABEL}" >/dev/null 2>&1 \
    || { echo "WRONG LUKS KEY PROVIDED. EXITING SETUP." ; exit 4; }
}

check_initial_luks_keyfile() {
  KEY_FILE="${1}"
  CRYPT_PARTITION="${2}"
  CRYPTROOT_LABEL="${3:=testfoo}"

  echo 'Check if proper LUKS Key is given for initial setup'
    cryptsetup open --key-file="${KEY_FILE}" --test-passphrase \
      "${CRYPT_PARTITION}" "${CRYPTROOT_LABEL}" >/dev/null 2>&1 \
    || { echo "WRONG LUKS KEY PROVIDED. EXITING SETUP." ; exit 4; }
}


initial_tpm2_setup() {
  PCR_BANK="${1}"
  PCR_VALUES_TO_USE="${2}"
  PERSISTANT_HANDLE_TO_USE="${3}"
  KEY_FILE="${4}"
  KEY_SCRIPT="${5}"
  TPM_KEYSLOT="${6}"
  CRYPTROOT_LABEL="${7}"
  ROOTCRYPTPARTUUID="${8}"
  CRYPT_PARTITION="${9}"
  EXTEND="${10}"
  SET_RECOVERY_KEY="${11}"
  RECOVERY_FILE="${12}"
  RECOVERY_SCRIPT_HELPER="${13}"
  RECOVERY_GROUPS="${14}"
  RECOVERY_GROUP_LENGTH="${15}"
  RECOVERY_KEYSLOT="${16}"
  KNOWN_UNKNOWN="${17}"
  PERSISTANT_OWNER_SRK_NODA="${18}"
  SECTPMCTL_KEYS="${19}"
  TPM_PASSWORD="${20}"

  check_tpm2_secureboot

  if [[ "x$KNOWN_UNKNOWN" == "x" ]]; then
    check_initial_luks_keyfile \
      "${KEY_FILE}" \
      "${CRYPT_PARTITION}" \
      "${CRYPTROOT_LABEL}"
  else
    check_initial_luks_passphrase \
      "${KNOWN_UNKNOWN}" \
      "${CRYPT_PARTITION}" \
      "${CRYPTROOT_LABEL}"
  fi

  add_tpm2_hook \
    "${PCR_BANK}" \
    "${SECTPMCTL_KEYS}"
  
  edit_initramfs_conf

  edit_crypttab \
    "${CRYPTROOT_LABEL}" \
    "${KEY_SCRIPT}" \
    "${ROOTCRYPTPARTUUID}"

  generate_tpm2_policy \
    "${PCR_BANK}" \
    "${PCR_VALUES_TO_USE}" \
    "${PERSISTANT_HANDLE_TO_USE}" \
    "${KEY_FILE}" \
    "${TPM_KEYSLOT}" \
    "${CRYPT_PARTITION}" \
    "${SET_RECOVERY_KEY}" \
    "${RECOVERY_FILE}" \
    "${RECOVERY_SCRIPT_HELPER}" \
    "${RECOVERY_GROUPS}" \
    "${RECOVERY_GROUP_LENGTH}" \
    "${RECOVERY_KEYSLOT}" \
    "${KNOWN_UNKNOWN}" \
    "${PERSISTANT_OWNER_SRK_NODA}" \
    "${SECTPMCTL_KEYS}" \
    "${TPM_PASSWORD}"

  generate_unseal_script \
    "${PCR_BANK}" \
    "${PERSISTANT_HANDLE_TO_USE}" \
    "${KEY_SCRIPT}" \
    "${CRYPT_PARTITION}" \
    "${EXTEND}" \
    "${SECTPMCTL_KEYS}" \
    "${TPM_PASSWORD}"

  update_initramfs
}

_check_input "$@"

# vim: ft=bash ts=2 sw=2
